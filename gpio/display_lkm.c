#include <linux/module.h>
#include <linux/init.h>
#include <linux/types.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/gpio.h>

/*disclaimer: not all of Raspberry pins
 * are available to be used as GPIOs */
#define CHARDEV_MINOR        19   /* start of minor numbers requested */
#define CHARDEV_MINOR_NUM    1    /* how many minors requested */
#define DEVICE_NAME "display_lkm" /* name that will be assigned to this device in /dev fs */
#define BUF_SIZE 512
#define NUM_COM 4 /* number of commands that this driver support */

#define LCDWIDTH 84
#define LCDHEIGHT 48

#define BL_GPIO 26
#define CLCK_GPIO 11
#define RST_GPIO 24
#define CE_GPIO 8
#define DC_GPIO 23
#define DIN_GPIO 10

#define PCD8544_POWERDOWN 0x04
#define PCD8544_ENTRYMODE 0x02
#define PCD8544_EXTENDEDINSTRUCTION 0x01

#define PCD8544_DISPLAYBLANK 0x0
#define PCD8544_DISPLAYNORMAL 0x4
#define PCD8544_DISPLAYALLON 0x1
#define PCD8544_DISPLAYINVERTED 0x5

// H = 0
#define PCD8544_FUNCTIONSET 0x20
#define PCD8544_DISPLAYCONTROL 0x08
#define PCD8544_SETYADDR 0x40
#define PCD8544_SETXADDR 0x80

// H = 1
#define PCD8544_SETTEMP 0x04
#define PCD8544_SETBIAS 0x10
#define PCD8544_SETVOP 0x80

const uint8_t empty [] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0010 (16) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0020 (32) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0030 (48) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0010 (16) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0020 (32) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0060 (96) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0010 (16) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0020 (32) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0090 (144) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0010 (16) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0020 (32) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x00C0 (192) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0010 (16) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0020 (32) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0030 (48) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0010 (16) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0020 (32) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0060 (96) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0010 (16) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0020 (32) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0090 (144) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0010 (16) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0020 (32) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0180 (384) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0090 (144) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0010 (16) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0020 (32) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x01C0 (448) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0090 (144) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0010 (16) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x01F0 (496) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const uint8_t pi_logo [] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0010 (16) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0xFC, 0xAE, 0x0E, 0x0E, 0x06, 0x0E, 0x06,   // 0x0020 (32) pixels
        0xCE, 0x86, 0x8E, 0x0E, 0x0E, 0x1C, 0xB8, 0xF0, 0xF8, 0x78, 0x38, 0x1E, 0x0E, 0x8E, 0x8E, 0xC6,   // 0x0030 (48) pixels
        0x0E, 0x06, 0x0E, 0x06, 0x0E, 0x9E, 0xFE, 0xFC, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0040 (64) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0050 (80) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0060 (96) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x0F, 0xFE,   // 0x0070 (112) pixels
        0xF8, 0xF0, 0x60, 0x60, 0xE0, 0xE1, 0xE3, 0xF7, 0x7E, 0x3E, 0x1E, 0x1F, 0x1F, 0x1F, 0x3E, 0x7E,   // 0x0080 (128) pixels
        0xFB, 0xF3, 0xE1, 0xE0, 0x60, 0x70, 0xF0, 0xF8, 0xBE, 0x1F, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x00,   // 0x0090 (144) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x00A0 (160) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x00B0 (176) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0,   // 0x00C0 (192) pixels
        0xE0, 0xFC, 0xFE, 0xFF, 0xF3, 0x38, 0x38, 0x0C, 0x0E, 0x0F, 0x0F, 0x0F, 0x0E, 0x3C, 0x38, 0xF8,   // 0x00D0 (208) pixels
        0xF8, 0x38, 0x3C, 0x0E, 0x0F, 0x0F, 0x0F, 0x0E, 0x0C, 0x38, 0x38, 0xF3, 0xFF, 0xFF, 0xF8, 0xE0,   // 0x00E0 (224) pixels
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x00F0 (240) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0100 (256) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0110 (272) pixels
        0x00, 0x7F, 0xFF, 0xE7, 0xC3, 0xC1, 0xE0, 0xFF, 0xFF, 0x78, 0xE0, 0xC0, 0xC0, 0xC0, 0xC0, 0xE0,   // 0x0120 (288) pixels
        0x60, 0x78, 0x38, 0x3F, 0x3F, 0x38, 0x38, 0x60, 0x60, 0xC0, 0xC0, 0xC0, 0xC0, 0xE0, 0xF8, 0x7F,   // 0x0130 (304) pixels
        0xFF, 0xE0, 0xC1, 0xC3, 0xE7, 0x7F, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0140 (320) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0150 (336) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0160 (352) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x7F, 0xFF, 0xF1, 0xE0, 0xC0, 0x80, 0x01,   // 0x0170 (368) pixels
        0x03, 0x9F, 0xFF, 0xF0, 0xE0, 0xE0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xE0, 0xE0, 0xF0, 0xFF, 0x9F,   // 0x0180 (384) pixels
        0x03, 0x01, 0x80, 0xC0, 0xE0, 0xF1, 0x7F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0190 (400) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x01A0 (416) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x01B0 (432) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,   // 0x01C0 (448) pixels
        0x03, 0x03, 0x07, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x3B, 0x71, 0x60, 0x60, 0x60, 0x60, 0x60, 0x71,   // 0x01D0 (464) pixels
        0x3B, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x01E0 (480) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x01F0 (496) pixels
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

/* buffer with set of supported commands */
const char * commands[NUM_COM] = {"on", "off", "bl_on", "bl_off"};
/* enumerators to match commands with values for following processing */
enum commands { on  = 0,
                off   = 1,
                bl_on = 2,
                bl_off = 3,
                na       = NUM_COM+1};

//enum direction {in, out};
enum state {poweron, poweroff};
enum blight {lighton, lightoff};

struct display_lkm_dev
{
    struct cdev cdev;

//    struct gpio pin;
    enum state state;
    enum blight blight;
};

static int display_lkm_open(struct inode *inode, struct file *filp);
static int display_lkm_release(struct inode *inode, struct file *filp);
static ssize_t display_lkm_read (struct file *filp, char *buf, size_t count, loff_t *f_pos);
static ssize_t display_lkm_write (struct file *filp, const char *buf, size_t count, loff_t *f_pos);


static struct file_operations display_lkm_fops =
{
    .owner = THIS_MODULE,
    .open = display_lkm_open,
    .release = display_lkm_release,
    .read = display_lkm_read,
    .write = display_lkm_write,
};

static int display_lkm_init(void);
static void display_lkm_exit(void);

static dev_t first;
struct display_lkm_dev display_device;
static struct class *cd_class;

static unsigned int which_command(const char * com)
{
    unsigned int i;

    for(i = 0 ; i < NUM_COM; i++)
    {
        if(!strcmp(com, commands[i]))
            return i;
    }
    return na;
}

static int display_lkm_open (struct inode *inode, struct file *filp)
{
    printk(KERN_DEBUG "[display_lkm_open] - open() method called\n");
    return 0;
}

static int display_lkm_release (struct inode *inode, struct file *filp)
{
    printk(KERN_DEBUG "[display_lkm_release] - close() method called\n");
    return 0;
}

static ssize_t display_lkm_read ( struct file *filp, char *buf, size_t count, loff_t *f_pos)
{
    printk(KERN_DEBUG "[display_lkm_release] - read() method called\n");
    return 0;
}

void SPIwrite(int c)
{
    gpio_set_value(CE_GPIO, 0);
    int i;
    int j;
    for (i = 0; i < 8; i++)  {
        gpio_set_value(DIN_GPIO, !!(c & (1 << (7 - i))));

        gpio_set_value(CLCK_GPIO, 1);
        for (j = 400; j > 0; j--); // clock speed, anyone? (LCD Max CLK input: 4MHz)
        gpio_set_value(CLCK_GPIO, 0);
    }
    gpio_set_value(CE_GPIO, 1);
}

void SPIcommand(int c)
{
    gpio_set_value(DC_GPIO, 0);
    SPIwrite(c);
}

void SPIdata(int c)
{
    gpio_set_value(DC_GPIO, 1);
    SPIwrite(c);
}

void display(void)
{
    int col, maxcol, p;

    for(p = 0; p < 6; p++)
    {
        SPIcommand(PCD8544_SETYADDR | p);
        // start at the beginning of the row
        col = 0;
        maxcol = LCDWIDTH-1;
        SPIcommand(PCD8544_SETXADDR | col);
        for(; col <= maxcol; col++) {
            //uart_putw_dec(col);
            //uart_putchar(' ');
            if (display_device.state == off) {
                SPIdata(empty[(LCDWIDTH*p)+col]);
            } else {
                SPIdata(pi_logo[(LCDWIDTH * p) + col]);
            }
        }
    }
    SPIcommand(PCD8544_SETYADDR );  // no idea why this is necessary but it is to finish the last byte?

}

static ssize_t display_lkm_write ( struct file *filp, const char *buf, size_t count, loff_t *f_pos)
{
    unsigned int gpio, len = 0;
    int i;
    char kbuf[BUF_SIZE];

    len = count < BUF_SIZE ? count-1 : BUF_SIZE-1;

    /* one more special kernel macro to copy data between
     * user space memory and kernel space memory
     */
    if(raw_copy_from_user(kbuf, buf, len) != 0)
        return -EFAULT;

    kbuf[len] = '\0';

    printk(KERN_INFO "[display_lkm_release] - Got request from user: %s\n", kbuf);

    /* perform a switch on recieved command value
     * to determine, what request is received
     */
    switch(which_command(kbuf))
    {
    case on:
    {
        if (display_device.state == poweron)
        {
            printk("[display_lkm_release] - Cannot power display on, it is enabled already\n", gpio);
            return -EPERM;
        }
        else
        {
            display_device.state = poweron;
            printk("[display_lkm_release] - Power display on\n");
            display();
        }
        break;
    }
    case off:
    {
        if (display_device.state == poweroff)
        {
            printk("[display_lkm_release] - Cannot power display off, it is disabled already\n", gpio);
            return -EPERM;
        }
        else
        {
            display_device.state = poweroff;
            printk("[display_lkm_release] - Power display off\n");
            display();
        }
        break;
    }
    case bl_on:
    {
        if (display_device.blight == lighton)
        {
            printk("[display_lkm_release] - Cannot enable BL, it is enabled already\n", gpio);
            return -EPERM;
        }
        else
        {
            printk("[display_lkm_release] - Enable light\n");
//            gpio_direction_output(BL_GPIO, 1);
            gpio_set_value(BL_GPIO, 1);
            display_device.blight = lighton;
        }
        break;
    }
    case bl_off:
        if (display_device.blight == lightoff)
        {
            printk("[display_lkm_release] - Cannot disable BL, it is disable already\n", gpio);
            return -EPERM;
        }
        else
        {
            printk("[display_lkm_release] - Disable light\n");
            //    gpio_direction_output(BL_GPIO, 1);
            gpio_set_value(BL_GPIO, 0);
            display_device.blight = lightoff;
        }
        break;
    }

    *f_pos += count;
    return count;
}

void setupDisplay(void){
    SPIcommand(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION );

    SPIcommand(PCD8544_SETBIAS | 0x4);

    int contrast = 55;
    if (contrast > 0x7f)
        contrast = 0x7f;

    SPIcommand( PCD8544_SETVOP | contrast);

    SPIcommand(PCD8544_FUNCTIONSET);

    SPIcommand(PCD8544_DISPLAYCONTROL | PCD8544_DISPLAYNORMAL);

    display();
}

static int __init display_lkm_init(void)
{
    int ret;
    struct device *dev_ret;
//    struct device *dev_ret;

    printk(KERN_DEBUG "[display_lkm_init] - init functions called");
    /* allocate minor numbers */
    if ((ret = alloc_chrdev_region(&first, CHARDEV_MINOR, CHARDEV_MINOR_NUM, DEVICE_NAME)) < 0)
    {
        return ret;
    }

    if (IS_ERR(cd_class = class_create(THIS_MODULE, DEVICE_NAME)))
    {
        printk(KERN_DEBUG "Cannot create class %s\n", DEVICE_NAME);
        unregister_chrdev_region(first, 1);
        return PTR_ERR(cd_class);
    }

    display_device.blight = lighton;
    display_device.state = poweron;
    display_device.cdev.owner = THIS_MODULE;

    gpio_direction_output(BL_GPIO, 0);
    gpio_direction_output(CLCK_GPIO, 0);
    gpio_direction_output(DIN_GPIO, 0);
    gpio_direction_output(CE_GPIO, 0);
    gpio_direction_output(DC_GPIO, 0);
    gpio_direction_output(RST_GPIO, 0);

    int j;
    for (j = 400; j > 0; j--);
    gpio_set_value(RST_GPIO, 1);
    gpio_set_value(CE_GPIO, 1);
    gpio_set_value(BL_GPIO, 1);

    setupDisplay();

    cdev_init(&display_device.cdev, &display_lkm_fops);

    if ((ret = cdev_add(&display_device.cdev, first, 1)) < 0)
    {
        device_destroy(cd_class, first);
        class_destroy(cd_class);
        unregister_chrdev_region(first, 1);
        return ret;
    }

    if (IS_ERR(dev_ret = device_create(cd_class, NULL, first, NULL, "Nokia5110LCD")))
    {
        class_destroy(cd_class);
        unregister_chrdev_region(first, 1);
        return PTR_ERR(dev_ret);
    }

    printk("[display_lkm_init] - Driver initialized\n");
    
    return 0;
}

static void __exit display_lkm_exit(void)
{
    cdev_del(&display_device.cdev);
    device_destroy(cd_class, first);
    class_destroy(cd_class);
    unregister_chrdev_region(first, 1);
    printk(KERN_INFO "[display_lkm_init] - unregistered from kernel");
}

module_init(display_lkm_init);
module_exit(display_lkm_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Wino Team");
MODULE_DESCRIPTION("Nokia 5110 LCD Display Kernel Module - Linux device driver for Raspberry Pi");
